typ = ##################
sur mac :
% port list opam
opam @2.0.7 ocaml/opam
##################

Correction TD/TP :
    
1. 
let rec inverser_liste l = 
        match l with 
        | [] -> []
        | t :: r -> (inverser_liste r)@[t];;
val inverser_liste : 'a list -> 'a list = <fun>          
pour tester : inverser_liste [1;2;3;4;5;6;7;8;9];;

let rec inverser_liste = function 
| []->[]
| t :: r -> (inverser_liste r) @ [t];;

esq ceci est correcte ? 
let rec inverse = function 
| [] -> [] 
| e:: tl -> (inverse tl)@e ;;
non e n'est pas une liste (tête de la liste) exact

2.
let rec occ n = function 
| []->0 
| e::tl-> if e==n then 1+(occ n tl) else (occ n tl) ;;

val occ : 'a -> 'a list -> int = <fun> 

pour tester : occ 2 [1;2;3;2;4;2];;
                
j'ai defini une fonction pour l'affichage   
Si vous êtes dans le toplevel, on n'a pas besoin d'afficher.


let rec print_list l = match l with
|[] -> ()
|e::f -> print_int e; print_string " "; print_list f;;
print_list (inverser_liste [1;2;3;4;5;6;7;8;9]);;
et sans la fonction mdrr ? je sais pas !!!
    
3.
let rec est_triee l = 
        match l with
        | [] -> true
        | [e] -> true
        | t :: e :: r -> 
                        if t>e 
                        then false 
                        else est_triee (e::r);;
                        
val est_triee : 'a list -> bool = <fun> 
                
pour tester :
est_triee [1;2;3;4;5;6;7;8;9];; true
est_triee [9;8;7;6;5;4;3;2;1];; false
est_triee [1;2;3;4;5;4;3;2;1];; false

Autre version (plus compacte) :

let rec is_sorted = function
  | [] | [ _ ] -> true   
  | a :: b :: tl -> (a <= b) && (is_sorted (b :: tl));;
    
4. 
let rec insertion_triee n = function
        | [] -> [n]
        | e :: lt -> if n<=e then n :: e :: lt 
                    else e :: (insertion_triee n lt);; 
val insertion_triee : 'a -> 'a list -> 'a list = <fun> 
pour tester : insertion_triee 5 [1;2;3;4;5;6;7;8;9];;

5.
let rec tri = function
  |[] -> []
  |e :: tl -> insertion_triee e (tri tl);;
val tri : 'a list -> 'a list = <fun>
pour tester : tri [5; 4; 3; 2; 1];;

Exercice 2 :
    
1.
type form =
  | Top | Bot
  | Var of string
  | Not of form
  | And of form * form
  | Or of form * form
  | Imp of form * form
  | Equ of form * form;;
  
  
let f1 = Top;;
let f2 = Var "A";;
let f3 = And (Var "A", Var "B");;
...

2.
print_string : affiche des chaînes de caractères.
- : string -> unit

let rec print_form = function
    | Top -> print_string "T"
    | Bot -> print_string "F"
    | Var s -> print_string s
    | Not f -> print_string "("; print_string "¬"; print_form f; print_string ")"
    | And (f1, f2) -> print_string "("; print_form f1; print_string " ^ "; print_form f2; print_string ")"
    | Or (f1, f2) -> print_string "("; print_form f1; print_string " v "; print_form f2; print_string ")"
    | Imp (f1, f2) -> print_string "("; print_form f1; print_string " => "; print_form f2; print_string ")"
    | Equ (f1, f2) -> print_string "("; print_form f1; print_string " <=> "; print_form f2; print_string ")";;


3.
let simplif_and = function
| And (f, Top) | And (Top, f) -> f
| And (f,Bot) | And (Bot,f) -> Bot
| e -> e;;

let simplif_or = function
| Or (f,Top) | Or (Top,f) -> Top
| Or(f,Bot) | Or (Bot,f) -> f
| e -> e;;

let simplif_imp = function
| Imp(f,Top) -> Top 
| Imp(Top,f) -> f
| Imp(f,Bot) -> Not f
| Imp(Bot,f) -> Top
| e -> e;; 

let C = function
| Equ(f,Top) | Equ(Top,f) -> f
| Equ(f,Bot) | Equ(Bot,f) -> Not f
| e -> e;;

let rec simplif_form = function
  | And (f1, f2) ->
     let f1' = simplif_form f1
     and f2' = simplif_form f2 in
     simplif_and (f1', f2')
  | Or (f1, f2) ->
     let f1' = simplif_form f1
     and f2' = simplif_form f2 in
     simplif_or (f1', f2')
  | Imp (f1, f2) ->
     let f1' = simplif_form f1
     and f2' = simplif_form f2 in
     simplif_imp (f1', f2')
  | Equ (f1, f2) ->
     let f1' = simplif_form f1
     and f2' = simplif_form f2 in
     simplif_equ (f1', f2')
  | f -> f;;


DEUX TESTS???
