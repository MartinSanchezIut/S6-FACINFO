TD OCaml : les objets

Pour faire du OCaml en ligne : https://try.ocamlpro.com/

Exercice 1 :
    
Réponse d'OCaml :

class min (xi : int) =
object (self)
  val mutable x = xi
  method get = x
  method set n = x <- n
  method min y = if self#get < y then self#get else y
end;;

class min_zero xi =
object
  inherit min xi
  method get = 0
end;;

let o1 = new min 4;;
let o2 = new min_zero 4;;

o1#min 2;;
- : int = 2
méthode get de min utilisée ; self#get = 4
La valeur liée à self est o1

o1#min 7;;
- : int = 4 
méthode get de min utilisée ; self#get = 4
La valeur liée à self est o1

o2#min 2;;
- : int = 0
méthode get de min_zero utilisée ; self#get = 0
La valeur liée à self est o2

o2#min (-2);;
- : int = -2
méthode get de min_zero utilisée ; self#get = 0
La valeur liée à self est o2


Exercice 2 :

On laisse un peu de temps pour que les gens puissent le faire un peu.

class account b =
  object ( self )
    val mutable balance = 0.0
    method get = balance
    method deposit a = balance <- balance +. a
    method withdraw a = balance <- balance -. a
    method print = print_float balance ; print_newline( )
    initializer self#deposit b
  end ;;

class interest_account b =
  object
    inherit account b
    method interest =
      balance <-  balance +.5. *.  balance /. 100.
  end ;;

class secure_account b =
  object
    inherit account b as super
    method withdraw a =
      if ( balance -. a) >= 0. then super#withdraw a
      else failwith "Not␣ enough␣money ! "
  end ;;

Classe banque :
	* ajouter un compte
	* calculer le solde de tous les comptes
	* afficher tous les comptes
	* retirer 5% à tous les comptes (frais bancaires) ça fait beaucoup

Documentation sur les listes :

https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html

val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a  (exemple ?)
List.fold_left f a [b1; ...; bn] is f (... (f (f a b1) b2) ...) bn.

Exemple :
List.fold_left (+) 0 [1;3;5;7];; 
- : int = 16

val iter : ('a -> unit) -> 'a list -> unit
List.iter f [a1; ...; an] applies function f in turn to a1; ...; an. It is equivalent to begin f a1; f a2; ...; f an; () end.

class bank =
object
  val mutable acc_list = []
  method add (c : account) = acc_list <- c :: acc_list
  method balance = List.fold_left (fun a b -> a +. b#get) 0. acc_list
  method print = List.iter (fun a -> a#print) acc_list
  method fees = List.iter (fun a -> a#withdraw (a#get *. 5. /. 100.)) acc_list
end;;

class ['a] collection =
object
  val mutable acc_list = []
  method add (a : 'a) = acc_list <- a::acc_list
end;;

class bank2 =
object
  inherit [account] collection
  method balance = List.fold_left (fun a b -> a +. b#get) 0. acc_list
  method print = List.iter (fun a -> a#print) acc_list
  method fees = List.iter (fun a -> a#withdraw (a#get *. 5. /.  100.)) acc_list
end;;

Exercice 3 :

class cte n =
object 
   val content = n
   method eval = content
   method print = print_int content
end;;

class inv (e : inv)  =
object 
  val content = e
  method eval = -content#eval 
  method print = 
	  print_string "(-"; 
      content#print;
      print_endline ")"  
end;;

class add (i:add) (j:add) =
  object
    val a = i
    val b = j
    method eval = a#eval + b#eval
    method print = print_string "("; 
      a#print;
      print_string " + "; 
      b#print;
      print_endline ")" 
  end;;
  
class sub (i:sub) (j:sub) =
  object
    val a = i
    val b = j
    method eval = a#eval - b#eval
    method print = print_string "("; 
      a#print;
      print_string " - "; 
      b#print;
      print_endline ")" 
  end;;
  
class mul (i:mul) (j:mul) =
  object
    val a = i
    val b = j
    method eval = a#eval * b#eval
    method print = print_string "("; 
      a#print;
      print_string " * "; 
      b#print;
      print_endline ")" 
  end;;
  
class div (i : div) (j : div) = 
  object
    val a = i
    val b = j
    method eval = a#eval / b#eval
    method print = print_string "("; 
      a#print;
      print_string " / "; 
      b#print;
      print_endline ")" 
  end;;
  
Note :
Tous les types cte, inv, add, sub, mul et div sont égaux
(OCaml ne regarde que les méthodes avec leurs types).

Non, il n'est pas nécessaire de créer une super-classe expr.

On peut avoir des exemples qui utilisent la classe inv svp ?
 UN EXEMPLE:
# let k = new cte 10;;
# let e = new inv k ;;
val e : inv = <obj>
# e#eval;;
- : int = -10
# e#print ;;
(-10)
- : unit = () 
 
Autre exemple :
# let e = new inv (new cte 10);;
équivalent

Autre exemple :
# let a = new add (new inv (new cte 2)) (new cte 4)
# a#eval;;
- : int = 2

Exercice 4 :

class virtual ['a] abr = 
object
  method virtual insert : 'a -> 'a abr
  method virtual find : 'a -> bool
end;;

class ['a] empty =
object
  inherit ['a] abr
  method insert n = new node n (new empty) (new empty)
  method find n = false
end

and ['a] node n (l : 'a abr) (r : 'a abr) =
object (self)
  inherit ['a] abr
  val value = n
  val mutable left = l
  val mutable right = r
  method insert (n : 'a) =
    (if n < value then left <- left#insert n
     else if n > value then right <- right#insert n);
	    (self :> 'a abr)  
  method find (n : 'a) =
    if n == value then true
    else if n < value then left#find n
    else right#find n
end;;
